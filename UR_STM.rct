

stm UR {
	requires ur_ops transition t0 {
		from i0
		to wait_for_move
	}
initial i0
	state wait_for_move {
	}

	transition t2 {
		from j0
		to reset_UR
	condition ur_curr_waypoint >= ur_n_waypoints
	}
	transition t3 {
		from j0
		to wait_for_move
	condition ur_curr_waypoint < ur_n_waypoints
		action ur_curr_waypoint = ur_curr_waypoint + 1
	}
	transition t5 {
		from reset_UR
		to wait_for_move
	}
state MoveJ {
		entry  moveJ ( ur_move . goal_angle1 , ur_move . goal_angle2 , jv )
	}
	state reset_UR {
		entry ur_curr_waypoint = 0 ; done
	}
	transition t6 {
		from MoveJ
		to j0
	}
	event move : UR_move
	event done

	junction j0
	transition t8 {
		from calc_vel
		to MoveJ
	}

	final f0

	transition t1 {
		from wait_for_move
		to calc_dist
		trigger move ? ur_move
	}
event out_of_sync
	state calc_vel {
	entry
	if jd1 > jd2 then jv = jd1/ur_move.goal_time else jv = jd2/ur_move.goal_time end
	}

	transition t4 {
		from calc_dist
		to calc_vel
		condition ur_move . goal_time >= 0
	}
	transition t7 {
		from calc_dist
		to f0
		condition ur_move . goal_time < 0
		action out_of_sync
	}
	const ur_n_waypoints : nat = 10
	var ur_curr_waypoint : nat = 0
var ur_move : UR_move
	var jd1 : real
	var jd2 : real
	var jv : real
	state calc_dist {
		entry
		jd1 = ur_move.goal_angle1-ur_move.curr_angle1;
		jd2 = ur_move.goal_angle2-ur_move.curr_angle2
	}
}

